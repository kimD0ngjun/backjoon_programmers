"""
https://www.acmicpc.net/problem/1300
"""

# 입력
N = int(input())
k = int(input())

"""
A를 직접 구축 후, 계산하는 과정은 아닌 것 같음
100000을 입력하니 로컬에서도 뻑뻑해짐
"""

# A = [[0 for _ in range(N)] for _ in range(N)]
#
# for i in range(N):
#     for j in range(N):
#         A[i][j] = (i + 1) * (j + 1)
#
# print(A)

"""
만약 k가 13이 입력되면
B[k]보다 '작거나 같은' 숫자의 개수가 13개여야 함

각 단위 row 배열에서 B[k]보다 작거나 같은 숫자의 개수를 세리는 것을 기준으로 이진 탐색

ex) N == 5, k == 13 이라면

1  2  3  4  5
2  4  6  8 10
3  6  9 12 15
4  8 12 16 20
5 10 15 20 25

A의 형태가 위와 같음, 
만일 기준 계산을 9부터 둔다면
9보다 '작거나 같은' 숫자들 개수를 각 라인에서 세린다

1  2  3  4  5 -> 5개
2  4  6  8 10 -> 4개
3  6  9 12 15 -> 3개
4  8 12 16 20 -> 2개
5 10 15 20 25 -> 1개

count == 15개, 즉 B[k]는 9보다 '작거나 같은' 숫자
그래서 더 작은 7을 B[k]에 둔다면

1  2  3  4  5 -> 5개
2  4  6  8 10 -> 3개
3  6  9 12 15 -> 2개
4  8 12 16 20 -> 1개
5 10 15 20 25 -> 1개

count == 12개, 즉 B[k]는 7보다 '큰' 수
그래서 더 큰 8을 B[k]에 둔다면

1  2  3  4  5 -> 5개
2  4  6  8 10 -> 4개
3  6  9 12 15 -> 2개
4  8 12 16 20 -> 2개
5 10 15 20 25 -> 1개

count == 14개, 즉 B[k]는 8보다 '작거나 같은' 수
7보다 크고 8보다 작거나 같은 수는 8

근데 그 연산 대상인 수 기준을 어떻게 삼지

1  2  3  4  5 -> 5개
2  4  6  8 10 -> 5개
3  6  9 12 15 -> 4개
4  8 12 16 20 -> 3개
5 10 15 20 25 -> 2개

기준 계산을 k, 즉 13으로 삼은 경우
count == 19개, 즉 B[k]는 13, 즉 k보다 '작거나 같은' 수

중복되는 숫자도 있을 거고 항상 B[k]는 k보다 작거나 같은 수를 만족
같은 수는 1이겠지

left 초기값: 1
right 초기값: k

라인별 작거나 같은 개수: mid // 라인 (몫) 혹은 N개
"""

left = 1
right = k
answer = 0

while left <= right:
    count = 0  # 작거나 같은 숫자들 개수
    mid = (left + right) // 2

    # 인덱스가 1부터 시작
    # 아 잠만 A를 직접 구축할 수 없네...?
    for i in range(1, N + 1):
        count += min(mid // i, N)

    if count >= k:
        answer = mid
        right = mid - 1
    else:
        left = mid + 1

print(answer)
