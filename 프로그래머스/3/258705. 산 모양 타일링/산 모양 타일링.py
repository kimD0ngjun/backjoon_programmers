"""
결국 주어진 모양에서, 면으로 인접한 삼각형 2개(마름모)를 고르는 경우의 수
아래 삼각형 갯수는 n+1개
아래 삼각형 기준 인덱스 초기 시작은 0, 1로 하면 될 것 같은데(n은 무조건 1 이상 보장)

단계적으로 풀이해보자

마름모는 왼쪽 아래로 치우쳐진 마름모만 있고 tops가 없을 떄, 마름모와 삼각형으로 채우는 풀이 -> 1
여기에 이제 위에 삼각형이 덧붙여져서 다이아몬드 마름모가 추가된 풀이 -> 2
마지막으로 여기에 오른쪽 아래로 치우처진 마름모 타일이 추가된 풀이 -> 3

반복문 바텀업 구조를 먼저 갖추고 여기에 1번 풀이 추가하고 그다음에 2번 풀이 추가하고 그다음에 3번 풀이 추가하는?
어렵네.. 1번 3번을 묶고 2번으로 다시 해보자
단위를 다시 사다리꼴로 잡았을 때, 겹치는 영역 중복 배제 필요
*직전 사다리꼴에서 오른쪽 아래로 쏠린 마름모가 배치되면 현재 사다리꼴에서 왼쪽 아래로 쏠린 마름모 배치 불가능*
그럼 별표 상황을 고려하지 않아도 되는 케이스는 삼각형이 얹어졌을 때의 마름모 배치 혹은 그냥 삼각형만 배치?
"""
def solution(n, tops):
    # i번쨰 사다리꼴에 대해서
    # idx 0: 오른쪽 아래로 쏠린 마름모를 채운 경우 -> 직전 사다리꼴에서 뭔 짓을 해도 영향 x
    # idx 1: 왼쪽 아래로 쏠린 마름모를 채운 경우 + 다이아몬드(top[idx] == 1) + 삼각형만
    memo = [[0, 0] for _ in range(n)]
    memo[0][0] = 1
    memo[0][1] = 3 if tops[0] == 1 else 2

    for i in range(1, n):
        # idx 0 갱신은 쉬운데...
        memo[i][0] = memo[i-1][0] + memo[i-1][1]

        # idx 1 갱신
        if tops[i] == 1:
            """
            삼각형이 있다면
            직전 단계에서 idx 0 case -> 가능한 건 다이아몬드 마름모 배치 + 삼각형만 : 2개
            직전 단게에서 idx 1 case -> 가능한 건 왼쪽 아래로 몰린 마름모 배치 + 다이아몬드 마름모 배치 + 삼각형만 : 3개
            """
            memo[i][1] = memo[i-1][0] * 2 + memo[i-1][1] * 3
        else:
            """
            삼각형이 없다면
            직전 단계에서 idx 0 case -> 가능한 건 마름모 배치 없이 삼각형만 : 1개
            직전 단계에서 idx 1 case -> 가능한 건 왼쪽 아래로 몰린 마름모 배치 + 삼각형만 : 2개
            """
            memo[i][1] = memo[i-1][0] + memo[i-1][1] * 2

        memo[i][0] %= 10_007
        memo[i][1] %= 10_007

    answer = (memo[-1][0] + memo[-1][1])
    return answer % 10_007

"""
현재 재귀 단위가 직전 단계에 영향을 끼치는지?
1. 최대한 안끼치는 방향으로 먼저 단위 작성
2. 끼치는 경우는 별도 고려하기
"""


# print(solution(4, [1, 1, 0, 1]))
# print(solution(2, [0, 1]))
# print(solution(10, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))
# print(solution(3, [0, 0, 0])) # 6
# print(solution(3, [0, 1, 0]))
# print(solution(3, [1, 0, 1]))
# print(solution(3, [0, 1, 1]))
# print(solution(3, [1, 1, 1]))

# print(solution(2, [0, 0])) #
# print(solution(2, [1, 0])) #
# print(solution(2, [0, 1])) #
# print(solution(2, [1, 1])) #