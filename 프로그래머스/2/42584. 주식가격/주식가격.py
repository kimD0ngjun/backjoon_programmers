"""
각 요소의 뒤의 놈들과 비교해야함
자신 비교 직후 요소들 낮은값 포착되면 거기까지의 길이만

일단 나중에 다시 회복된 값은 고려하지 않음
그냥 바로 직후의 값이 언제부터 떨어지는지 그 시간 간격만 체킹
이중 반복문 말고 스택으로 풀 수 있을 것 같은데 예를 들어

2341.. 이렇다면

다음 값이 직전 값보다 크면 스택에 넣고 넣고 하다가... 4 -> 1 같은 시점이 오면
일단 스택에 있는 2,3,4 팝하면서 각요소별 팝카운팅(4는 1, 3은 2, 2는 3)
그리고 1은 스택에 넣고

이거 큐 문제인줄 알았는데 스택 문제였네;

스택 요소: (자신의 가격, 투입 시점)

인덱스 i에서 가져오는 값: prices[i] -> i 시점의 주식 가격
prices[i]는 직전 값들과 전부 비교 대상이 된다(직전 값들 입장에서 자신보다 작은 값인지 확인해야 함)
직전 애들 입장에서 만약 작은 값이라면? -> 그제야 팝한다
팝은 prices[i]보다 작거나 같은 애가 나오기 전까지 이뤄지며, 팝 카운팅만큼 각각 더한 게, 곧 '가격이 떨어지지 않은 기간'
팝했을 때 나온 [가격, 인덱스] 를 이용해서 별도의 결과 리스트[인덱스] = 카운팅 합계 업뎃하기

즉, 매 반복문마다 prices[i]는 직전 애들과 비교 대상이 될 수밖에 없음
"""
def solution(prices):
    answer = [0] * len(prices)

    stack = [(prices[0], 0)]

    for i in range(1, len(prices)):
        # 바로 직전(스택 꼭대기)와 비교하면 그 이전의 것들 전부 비교 가능
        while stack and stack[-1][0] > prices[i]:
            _, index = stack.pop()
            # i - index? 같은 값으로 바꿔야 될듯
            answer[index] = i - index

        stack.append((prices[i], i))

    # # 나머지 전부 팝하면서 길이 카운팅
    while stack:
        _, index = stack.pop()
        answer[index] = len(prices) - index - 1

    return answer