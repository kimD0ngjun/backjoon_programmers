class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:

        # 인덱스 저장용 해시맵(key: 값, value: 인덱스)
        index_dict = {}
        
        # 차이값으로 판별
        for i in range(len(nums)):
            # 차이의 값이 곧 이전에 훑어봤을 값
            value = target - nums[i]
            
            if value in index_dict:
                return [index_dict[value], i]
            
            # 없으면 추후에 써먹게 저장 혹은 인덱스 업데이트
            index_dict[nums[i]] = i
            


# 맞습니다. 이것은 배열과 해시맵의 자료구조의 차이로 인한 것입니다.

# 배열(Array): 배열은 인덱스를 사용하여 각 요소에 직접 접근할 수 있는 자료구조입니다. 따라서 특정 인덱스의 요소를 찾는 데는 O(1)의 시간이 소요됩니다. 그러나 요소를 찾기 위해 배열을 선형으로 탐색해야 하는 경우, 최악의 경우 O(n)의 시간이 걸릴 수 있습니다.

# 해시맵(Hash Map): 해시맵은 키-값 쌍을 저장하는 자료구조로, 각 키에 대한 해시 함수를 사용하여 키의 해시 값을 계산하고, 이 해시 값을 인덱스로 사용하여 배열에 저장합니다. 따라서 해시맵은 평균적으로 O(1)의 시간 복잡도로 요소를 조회할 수 있습니다. 즉, 특정 키를 기반으로 값을 찾는 데 걸리는 시간이 입력 크기와 무관하며 상수 시간에 가깝습니다.

# 따라서 해시맵은 요소를 찾는 데 상수 시간에 가까운 시간이 걸리므로 대부분의 경우에는 배열보다 효율적입니다. 특히 매우 큰 데이터셋에서는 해시맵을 사용하는 것이 더욱 중요합니다.